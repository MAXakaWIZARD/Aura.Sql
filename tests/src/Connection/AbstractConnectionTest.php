<?php
namespace Aura\Sql\Connection;

use PDO;
use Aura\Sql\ColumnFactory;
use Aura\Sql\Column;

/**
 * Test class for AbstractConnection.
 * Generated by PHPUnit on 2011-06-21 at 16:49:51.
 */
abstract class AbstractConnectionTest extends \PHPUnit_Framework_TestCase
{
    protected $extension;
    
    protected $dsn = [];
    
    protected $connection_params = array(
        'dsn'      => [],
        'username' => null,
        'password' => null,
        'options'  => [],
    );
    
    protected $connection_type;
    
    protected $connection;
    
    protected $table;
    
    protected $expect_quote_scalar;
    
    protected $expect_quote_array;
    
    protected $expect_quote_into;
    
    protected $expect_quote_values_in;
    
    protected $expect_quote_multi;
    
    public function setUp()
    {
        // skip if we don't have the extension
        if (! extension_loaded($this->extension)) {
            $this->markTestSkipped("Extension '{$this->extension}' not loaded.");
        }
        
        // database setup
        $db_setup_class = substr(get_class($this), 0, -4);
        $db_setup_class = str_replace('Connection', 'DbSetup', $db_setup_class);
        $this->db_setup = new $db_setup_class;
        
        // the connection
        $this->connection = $this->db_setup->getConnection();
        
        // the table
        $this->table = $this->db_setup->getTable();
    }
    
    public function testQuery()
    {
        $stm = "SELECT * FROM {$this->table}";
        $sth = $this->connection->query($stm);
        $this->assertInstanceOf('PDOStatement', $sth);
        $result = $sth->fetchAll(PDO::FETCH_ASSOC);
        $expect = 10;
        $actual = count($result);
        $this->assertEquals($expect, $actual);
    }
    
    public function testQueryWithData()
    {
        $stm = "SELECT * FROM {$this->table} WHERE id <= :val";
        $bind['val'] = '5';
        $this->connection->bindValues($bind);
        $sth = $this->connection->query($stm);
        $this->assertInstanceOf('PDOStatement', $sth);
        $result = $sth->fetchAll(PDO::FETCH_ASSOC);
        $expect = 5;
        $actual = count($result);
        $this->assertEquals($expect, $actual);
    }
    
    public function testQueryWithArrayData()
    {
        $stm = "SELECT * FROM {$this->table} WHERE id IN (:list) OR id = :id";
        
        $bind['list'] = [1, 2, 3, 4];
        $bind['id'] = 5;
        
        $this->connection->bindValues($bind);
        $sth = $this->connection->query($stm);
        $this->assertInstanceOf('PDOStatement', $sth);
        $result = $sth->fetchAll(PDO::FETCH_ASSOC);
        $expect = 5;
        $actual = count($result);
        $this->assertEquals($expect, $actual);
    }
    
    public function testPrepareWithQuotedStringsAndData()
    {
        $stm = "SELECT * FROM {$this->table}
                 WHERE 'leave :foo alone'
                 AND id IN (:list)
                 AND \"leave :bar alone\"";
        
        $bind = [
            'list' => [1, 2, 3, 4, 5],
            'foo' => 'WRONG',
            'bar' => 'WRONG',
        ];
        
        $this->connection->bindValues($bind);
        $sth = $this->connection->prepare($stm);
        
        $expect = str_replace(':list', "'1', '2', '3', '4', '5'", $stm);
        $actual = $sth->queryString;
        $this->assertSame($expect, $actual);
    }
    
    public function testFetchAll()
    {
        $stm = "SELECT * FROM {$this->table}";
        $result = $this->connection->fetchAll($stm);
        $expect = 10;
        $actual = count($result);
        $this->assertEquals($expect, $actual);
    }
    
    public function testFetchAssoc()
    {
        $stm = "SELECT * FROM {$this->table} ORDER BY id";
        $result = $this->connection->fetchAssoc($stm);
        $expect = 10;
        $actual = count($result);
        $this->assertEquals($expect, $actual);
        
        // 1-based IDs, not 0-based sequential values
        $expect = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        $actual = array_keys($result);
        $this->assertEquals($expect, $actual);
    }
    
    public function testFetchCol()
    {
        $stm = "SELECT id FROM {$this->table} ORDER BY id";
        $result = $this->connection->fetchCol($stm);
        $expect = 10;
        $actual = count($result);
        $this->assertEquals($expect, $actual);
        
        // // 1-based IDs, not 0-based sequential values
        $expect = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
        $this->assertEquals($expect, $result);
    }
    
    public function testFetchValue()
    {
        $stm = "SELECT id FROM {$this->table} WHERE id = 1";
        $actual = $this->connection->fetchValue($stm);
        $expect = '1';
        $this->assertEquals($expect, $actual);
    }
    
    public function testFetchPairs()
    {
        $stm = "SELECT id, name FROM {$this->table} ORDER BY id";
        $actual = $this->connection->fetchPairs($stm);
        $expect = [
          1  => 'Anna',
          2  => 'Betty',
          3  => 'Clara',
          4  => 'Donna',
          5  => 'Fiona',
          6  => 'Gertrude',
          7  => 'Hanna',
          8  => 'Ione',
          9  => 'Julia',
          10 => 'Kara',
        ];
        $this->assertEquals($expect, $actual);
    }
    
    public function testFetchOne()
    {
        $stm = "SELECT id, name FROM {$this->table} WHERE id = 1";
        $actual = $this->connection->fetchOne($stm);
        $expect = [
            'id'   => '1',
            'name' => 'Anna',
        ];
        $this->assertEquals($expect, $actual);
    }
    
    public function testQuoteValuesIn()
    {
        // no placeholders
        $actual = $this->connection->quoteValuesIn('foo = bar', "'zim'");
        $expect = 'foo = bar';
        $this->assertEquals($expect, $actual);
        
        // one placeholder, one value
        $actual = $this->connection->quoteValuesIn("foo = ?", "'bar'");
        $this->assertEquals($this->expect_quote_into,$actual);
        
        // many placeholders, many values
        $actual = $this->connection->quoteValuesIn("foo = ? AND zim = ?", ["'bar'", "'baz'"]);
        $this->assertEquals($this->expect_quote_values_in, $actual);
        
        // many placeholders, too many values
        $actual = $this->connection->quoteValuesIn("foo = ? AND zim = ?", ["'bar'", "'baz'", "'gir'"]);
        $this->assertEquals($this->expect_quote_values_in, $actual);
    }
    
    public function testQuoteName()
    {
        // table AS alias
        $actual = $this->connection->quoteName('table AS alias');
        $this->assertEquals($this->expect_quote_name_table_as_alias, $actual);
        
        // table.col AS alias
        $actual = $this->connection->quoteName('table.col AS alias');
        $this->assertEquals($this->expect_quote_name_table_col_as_alias, $actual);
        
        // table alias
        $actual = $this->connection->quoteName('table alias');
        $this->assertEquals($this->expect_quote_name_table_alias, $actual);
        
        // table.col alias
        $actual = $this->connection->quoteName('table.col alias');
        $this->assertEquals($this->expect_quote_name_table_col_alias, $actual);
        
        // plain old identifier
        $actual = $this->connection->quoteName('table');
        $this->assertEquals($this->expect_quote_name_plain, $actual);
        
        // star
        $actual = $this->connection->quoteName('*');
        $this->assertEquals('*', $actual);
        
        // star dot star
        $actual = $this->connection->quoteName('*.*');
        $this->assertEquals('*.*', $actual);
    }
    
    public function testQuoteNamesIn()
    {
        $sql = "*, *.*, foo.bar, CONCAT('foo.bar', \"baz.dib\") AS zim";
        $actual = $this->connection->quoteNamesIn($sql);
        $this->assertEquals($this->expect_quote_names_in, $actual);
    }
    
    public function testLimit()
    {
        $actual = 'SELECT * FROM whatever ';
        $this->connection->limit($actual, 10, 20);
        $expect = 'SELECT * FROM whatever LIMIT 10 OFFSET 20';
        $this->assertSame($expect, $actual);
    }
    
    public function testLastInsertId()
    {
        $stm = "INSERT INTO {$this->table} (name) VALUES (:name)";
        $this->connection->bindValues(['name' => 'Lora']);
        $this->connection->exec($stm);
        
        // did we get the right last ID?
        $actual = $this->connection->lastInsertId($this->table, 'id');
        $expect = '11';
        $this->assertEquals($expect, $actual);
        
        // did it insert?
        $actual = $this->connection->fetchOne("SELECT id, name FROM {$this->table} WHERE id = 11");
        $expect = ['id' => '11', 'name' => 'Lora'];
        $this->assertEquals($actual, $expect);
    }
}
